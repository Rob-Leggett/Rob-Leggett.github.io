/* scripts/generate-sitemap.js
 * Generate a sitemap.xml from content/publish/*.mdx? and a few static routes.
 * Usage: node scripts/generate-sitemap.js
 */

import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { pathToFileURL } from 'url';

const isDirectRun =
  process.argv[1] && import.meta.url === pathToFileURL(process.argv[1]).href;

const ROOT = process.cwd();
const PUBLISH_DIR = path.join(ROOT, 'content', 'publish');
const PUBLIC_DIR = path.join(ROOT, 'public');

const SITE_URL = process.env.SITE_URL || 'https://robertleggett.com.au';

const STATIC_ROUTES = ['/', '/blog/'];

function isoDate(d) {
  try {
    if (!d) return undefined;
    const dt = new Date(d);
    if (isNaN(dt.getTime())) return undefined;
    return dt.toISOString();
  } catch {
    return undefined;
  }
}

function escapeXml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function loadPosts() {
  if (!fs.existsSync(PUBLISH_DIR)) return [];
  const files = fs
    .readdirSync(PUBLISH_DIR)
    .filter((f) => /\.mdx?$/i.test(f));

  const posts = files.map((file) => {
    const filePath = path.join(PUBLISH_DIR, file);
    const raw = fs.readFileSync(filePath, 'utf8');
    const { data } = matter(raw);

    const fallbackSlug = file.replace(/\.mdx?$/i, '');
    // Prefer frontmatter.slug if present; otherwise filename
    const slug = (data.slug || fallbackSlug).replace(/^\//, '').replace(/\/$/, '');
    // Normalize to blog path if your pages live under /blog/[slug]
    const urlPath = `/blog/${slug}/`;

    return {
      loc: SITE_URL + urlPath,
      lastmod: isoDate(data.date), // optional
      changefreq: 'weekly',
      priority: '0.7',
    };
  });

  // Newest first (optional)
  posts.sort((a, b) => {
    const ta = a.lastmod ? Date.parse(a.lastmod) : 0;
    const tb = b.lastmod ? Date.parse(b.lastmod) : 0;
    return tb - ta;
  });

  return posts;
}

function buildUrlEntry({ loc, lastmod, changefreq, priority }) {
  const parts = [
    `  <url>`,
    `    <loc>${escapeXml(loc)}</loc>`,
  ];
  if (lastmod) parts.push(`    <lastmod>${escapeXml(lastmod)}</lastmod>`);
  if (changefreq) parts.push(`    <changefreq>${escapeXml(changefreq)}</changefreq>`);
  if (priority) parts.push(`    <priority>${escapeXml(priority)}</priority>`);
  parts.push(`  </url>`);
  return parts.join('\n');
}

function main() {
  // Ensure public/ exists
  if (!fs.existsSync(PUBLIC_DIR)) fs.mkdirSync(PUBLIC_DIR, { recursive: true });

  // Build static URLs
  const staticUrls = STATIC_ROUTES.map((route) => ({
    loc: SITE_URL + route,
    changefreq: 'monthly',
    priority: '0.6',
  }));

  // Posts
  const postUrls = loadPosts();

  // Merge
  const urls = [...staticUrls, ...postUrls];

  const xml =
    `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by scripts/generate-sitemap.js -->
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${urls.map(buildUrlEntry).join('\n')}
</urlset>
`;

  const outPath = path.join(PUBLIC_DIR, 'sitemap.xml');
  fs.writeFileSync(outPath, xml, 'utf8');
  console.log(`✅ Sitemap generated → ${outPath}`);
  console.log(`   URLs: ${urls.length}`);
  console.log(`   SITE_URL: ${SITE_URL}`);
}

if (isDirectRun) {
  try {
    await main(); // top-level await is allowed in ESM
  } catch (err) {
    console.error('❌ Error generating sitemap:', err);
    process.exit(1);
  }
}