---
title: "Seizing the Future - An Eager Approach to Digital Identity Migration Strategies"
date: "2024-10-17"
slug: "seizing-the-future-an-eager-approach-to-digital-identity-migration-strategies"
status: "publish"
feature_image: "/blog/seizing-the-future-an-eager-approach-to-digital-identity-migration-strategies/feature-image.png"
---

In today's digital age, managing digital identities efficiently and securely has become a cornerstone for any online platform. Among the various strategies to upgrade or shift digital identity management systems, two approaches stand out: Eager Migration and Lazy Migration, each with its unique advantages and challenges. In this exploration, we delve into the nuances, particularly focusing on the proactive stance of Eager Migration.

## Before you start

About this post:

*   5 - 10 min average reading time
*   Suitable for intermediate through to advanced

What you will gain reading this post:

*   An overview of the migration strategies
*   A guide on choosing the best approach to support your solution

What you can do to help support:

*   **Like, comment and share this article**
*   **Follow this blog** to receive notifications of new postings

Now, let's get started.

## Migration Strategies

When transitioning to a new identity platform or system, choosing the right migration strategy is essential to ensure minimal disruption and optimal user experience. Two primary strategies are **Eager Migration** and **Lazy Migration**. Each has its strengths and weaknesses, and the choice depends on the system’s goals, user base, and operational constraints.

### Eager Migration

Eager Migration represents a proactive and decisive approach, transferring all user accounts and associated data to the new system in a single, large-scale migration before any user interaction is required.

**Advantages:**

*   **Immediate Consistency:** All users are migrated simultaneously, ensuring system-wide consistency and eliminating version discrepancies.
*   **Enhanced User Experience:** Users seamlessly access the new system without needing to take any action, such as re-registering or re-authenticating.
*   **Predictable Rollout:** The migration is carefully planned and executed, reducing risks of unexpected user issues post-launch.
*   **Simplified Support:** Customer support teams can focus on the new system without maintaining old versions or dealing with fragmented migrations.

**Challenges:**

*   **High Complexity and Risk:** Large-scale migrations require precise coordination and thorough testing. Any errors can affect the entire user base.
*   **Downtime Risk:** The system might require a maintenance window, affecting availability during the migration process.
*   **Resource Intensive:** Requires significant upfront investment in planning, development, and execution.

Eager migration is ideal for platforms prioritizing consistency and control, especially when maintaining multiple systems or versions would be costly or impractical.

### Lazy Migration

Lazy Migration, on the other hand, takes a more gradual approach. Rather than migrating all users at once, accounts are transferred only when users engage with the system (e.g., when they log in or perform an action).

**Advantages:**

*   **Minimized Initial Risk:** There is no need for a large-scale migration event, reducing the risk of major disruptions.
*   **Resource Optimization:** Migration occurs in smaller batches over time, spreading out the operational load.
*   **Less Downtime:** Users experience minimal disruption since the system doesn’t need to undergo a full-scale shutdown.
*   **User Self-Management:** Users are naturally prompted to complete the migration process, reducing the need for preemptive handling.

**Challenges:**

*   **Fragmented State:** For a period, some users will remain on the old system while others are on the new one, potentially causing inconsistencies.
*   **User Experience Dependency:** Users must take action to complete the migration, which may frustrate or confuse less engaged users.
*   **Support Complexity:** Customer support may need to handle issues on both the old and new systems until the migration is complete.
*   **Longer Transition Period:** The full migration can take weeks or months, depending on user engagement patterns.

Lazy migration works well when systems need to be highly available throughout the transition and when it’s acceptable for users to migrate at their own pace.

**Choosing the Right Strategy**

The choice between eager and lazy migration depends on several factors:

*   **System Urgency:** If rapid consistency is required, eager migration may be the better option.
*   **User Engagement Levels:** For highly engaged users, lazy migration can allow a more seamless experience.
*   **Operational Resources:** Eager migration requires more upfront resources, whereas lazy migration spreads the load over time.
*   **Tolerance for Downtime:** If downtime is acceptable, eager migration can offer a cleaner transition. Otherwise, lazy migration provides continuity.

Ultimately, both strategies have their place in migration planning. Some organizations may even adopt a **hybrid approach**, using eager migration for critical accounts while employing lazy migration for less critical users to balance risks and resources.

## Eager Migration: A Proactive Leap Forward

Eager Migration represents a bold, comprehensive strategy for transitioning user accounts to a new system in one fell swoop, before the necessity for user login arises. This method boasts immediate system-wide consistency, a critical advantage for platforms striving for seamless user experiences across interfaces. However, it's not without its complexities, especially when handling extensive user bases.

### The Promise of Uniformity and Immediate Integration

The allure of Eager Migration lies in its promise of instant uniformity and integration. By transferring all user accounts to the new system in advance, platforms can ensure a consistent experience for both users and administrators from the outset. This approach eliminates the staggered transition periods often seen with other methods, aiming for a frictionless switch for all stakeholders involved.

### The Eager Migration Path: Steps to Seamless Transition

Eager Migration unfolds in several calculated steps, beginning with the comprehensive transfer of user data from platforms like Auth0 to the new system. This includes the meticulous reformatting of user information to fit the new environment, ensuring password hashes and other vital details are seamlessly integrated.

#### 1\. Dividing Users into Tenants (assuming multi-tenant support required)

A pivotal step in Eager Migration is sorting users into appropriate tenants within the new system, often based on their email domain. This categorization facilitates better management and a more organized transition.

#### 2\. Streamlining Sign-On Processes

Maintaining familiar sign-in processes is crucial. Eager Migration allows users to log in using their previous credentials, minimizing disruptions and maintaining a sense of continuity.

#### 3\. Finalizing the Move

The migration culminates with a final review, ensuring all users are correctly moved, and their accounts function as expected. This phase is critical for identifying and addressing any lingering issues, ensuring a successful migration.

#### 4\. Challenges and Considerations

Despite its advantages, Eager Migration is not without challenges. The strategy requires meticulous planning and execution, especially concerning data compatibility and user privacy. Moreover, the potential for "login challenges" with certain password hashes, like bcrypt, underscores the need for thorough testing and possibly vendor support.

## Concluding Thoughts

Eager Migration is a robust strategy for platforms seeking immediate consistency and minimal user disruption during digital identity system transitions.

While it demands significant upfront effort and careful consideration of potential challenges, its benefits in terms of user experience and system integrity are undeniable.

As digital platforms continue to evolve, strategies like Eager Migration offer a forward-thinking approach to managing the ever-important aspect of digital identity.

## Let's walk through a working example

### Scenario: **Migrating from Auth0 to GCP Identity Platform**

#### **_main.go_**

This supports both **global** and **tenant-specific user migrations**, providing flexibility for various migration scenarios

A simple server that runs on http://localhost:8080 with [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) enabled. The server will expose two endpoints:

*   http://localhost:8080/migration/auth0/export-import-users
*   http://localhost:8080/migration/auth0/tenant/&#123;tenantId&#125;/export-import-users

The design allows migration of users specific to a **tenant**, identified by &#123;tenantId&#125; in the URL. Both routes respond to **GET** and **OPTIONS** requests.

```go package main import ( "firebase-admin-auth-api-poc/handlers/auth0" "firebase-admin-auth-api-poc/handlers/middleware/cors" "firebase-admin-auth-api-poc/util" firebase "firebase.google.com/go/v4" "fmt" "github.com/gorilla/mux" "log" "net/http" ) func main() &#123; fm := util.NewFirebaseManager() router := mux.NewRouter() configureMigration(router, fm) fmt.Println("Server started on :8080") log.Fatal(http.ListenAndServe(":8080", cors.EnableCORS(router.ServeHTTP))) &#125; func configureMigration(router \*mux.Router, fm \*firebase.App) &#123; router.HandleFunc("/migration/auth0/export-import-users", auth0.ExportImportUsersHandler(fm)).Methods("GET", "OPTIONS") router.HandleFunc("/migration/auth0/tenant/&#123;tenantId&#125;/export-import-users", auth0.ExportImportUsersHandler(fm)).Methods("GET", "OPTIONS") &#125; ```

#### **_export\_import\_users.go_**

This code provides an HTTP API endpoint to **migrate users from Auth0 to Firebase**. It ensures that users are seamlessly exported from Auth0, converted into a Firebase-compatible format, and imported into the specified Firebase tenant. It also **handles common errors** like missing tenant IDs and import failures, and limits imports to **1000 users per batch** to comply with GCP Identity Platform’s constraints.

```text package auth0 import ( "encoding/json" "firebase-admin-auth-api-poc/handlers/auth0/helpers" u "firebase-admin-auth-api-poc/handlers/users" "firebase-admin-auth-api-poc/util" firebase "firebase.google.com/go/v4" "firebase.google.com/go/v4/auth" "fmt" "github.com/gorilla/mux" "net/http" ) type ExportImportResults struct &#123; Users \[\]\*helpers.UserToImport `json:"users"` Results \*auth.UserImportResult `json:"results"` &#125; func ExportImportUsersHandler(fm \*firebase.App) func(w http.ResponseWriter, r \*http.Request) &#123; return func(w http.ResponseWriter, r \*http.Request) &#123; vars := mux.Vars(r) tenantId := vars\["tenantId"\] if tenantId == "" &#123; fmt.Println("unable to get tenant id") http.Error(w, "Unable to get tenant id", http.StatusBadRequest) &#125; users, err := exportAuth0Users() if err != nil &#123; http.Error(w, "Error exporting Auth0 users", http.StatusInternalServerError) &#125; tc, err := util.GetTenantClient(fm, tenantId) if err != nil &#123; fmt.Println("unable to get tenant client", err) http.Error(w, "Unable to get tenant client", http.StatusInternalServerError) &#125; importedUserResults, err := importAuth0Users(tc, users) if err != nil &#123; http.Error(w, "Error importing users", http.StatusInternalServerError) &#125; response := generateResponse(users, importedUserResults) w.Header().Set("Content-Type", "application/json") if err := json.NewEncoder(w).Encode(response); err != nil &#123; http.Error(w, "Error encoding users to JSON", http.StatusInternalServerError) &#125; &#125; &#125; func exportAuth0Users() (\[\]helpers.User, error) &#123; // Get Auth0 Users users, err := helpers.ExportAuth0UsersJob() if err != nil &#123; fmt.Println("error exporting users from Auth0", err) &#125; return users, err &#125; func importAuth0Users(tc \*auth.TenantClient, users \[\]helpers.User) (\*auth.UserImportResult, error) &#123; usersToImport := helpers.ConvertFromAuth0ToFirebaseUserToImport(users) // GCP Identity Platform has a limit of 1000 users per import, if you have more users // you need expand this code to break this into chunks of 1000 importUserResults, err := u.ImportUsers(tc, usersToImport) if err != nil &#123; return nil, fmt.Errorf("error importing users: %w", err) &#125; return importUserResults, err &#125; func generateResponse(users \[\]helpers.User, importResults \*auth.UserImportResult) ExportImportResults &#123; usersResult := helpers.ConvertFromAuth0ToLocalUserToImport(users) return ExportImportResults&#123; Users: usersResult, Results: importResults, &#125; &#125; ```

**Struct Definition:**

*   ExportImportResults: Holds the user data and the import results for the response.

**HTTP Handler:**

*   ExportImportUsersHandler(fm \*firebase.App): This function returns an HTTP handler that coordinates the **export and import of users** between Auth0 and Firebase.

**Workflow:**

*   Extracts the tenantId from the request path.
*   Exports users from Auth0 using exportAuth0Users().
*   Gets a Firebase tenant client for the given tenantId using util.GetTenantClient().
*   Imports the exported users into Firebase using importAuth0Users().
*   Generates and sends the response in **JSON** format with the import results.

Exporting Users from Auth0:

*   exportAuth0Users(): Calls a helper function ExportAuth0UsersJob() to retrieve users from Auth0.

Importing Users into Firebase:

*   importAuth0Users(tc \*auth.TenantClient, users \[\]helpers.User):
*   Converts Auth0 users to Firebase-compatible user objects.
*   Imports users into Firebase, with a **reminder to handle import limits (1000 users per batch)** if necessary.

Generating the Response:

*   generateResponse(): Prepares a response containing both the exported users and the import results.

**Error Handling:**

*   If there are **missing tenant IDs**, or **export/import failures**, appropriate **HTTP error responses** are returned.
*   Uses http.Error() to send error messages in case of issues during processing.

#### **_Example auth0-example-config.json_**

```text &#123; "auth0domain": "REPLACE WITH AUTH0 DOMAIN", "applications": &#123; "Auth0 Management API": &#123; "auth0clientID": "REPLACE WITH CLIENT ID", "auth0clientsecret": "REPLACE WITH CLIENT SECRET", "auth0audience": "https://REPLACE WITH AUTH0 DOMAIN/api/v2/" &#125; &#125; &#125; ```

#### **_auth0.go_**

This code is for exporting user data from **Auth0**. It provides functions to initiate, monitor, and download the user export job from Auth0, and it processes the exported data for further use.

**Reference:** Export User Passwords from Auth0 - [https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data)

**How It Works:**

*   **Configuration Handling:**
    *   Loads **Auth0 credentials** from a local JSON file.
*   **User Export Process**:
    *   For each configured Auth0 application:
        *   **Creates an export job** through the Auth0 API.
        *   **Polls the job status** until it completes.
        *   **Downloads the exported file** from the provided location.
        *   **Extracts user data** from the file.
        *   **Handling GZIP Compression**:
            *   If the downloaded file is GZIP-compressed, it decompresses it before extracting the user records.

```text package helpers import ( "bufio" "bytes" "compress/gzip" "context" "encoding/json" "fmt" "golang.org/x/oauth2/clientcredentials" "io" "io/ioutil" "net/http" "strings" "time" ) // config type Config struct &#123; Auth0Domain string `json:"auth0domain"` Applications map\[string\]Application `json:"applications"` &#125; type Application struct &#123; Auth0ClientID string `json:"auth0clientID"` Auth0ClientSecret string `json:"auth0clientsecret"` Auth0Audience string `json:"auth0audience"` &#125; // response type JobStatus struct &#123; Status string `json:"status"` Location string `json:"location,omitempty"` &#125; type JobResponse struct &#123; ID string `json:"id"` &#125; func ExportAuth0UsersJob() (\[\]User, error) &#123; clientConfig, err := getClientConfig() if err != nil &#123; return nil, fmt.Errorf("failed to get client config: %w", err) &#125; var domain = clientConfig.Auth0Domain var allUsers \[\]User // Aggregate users from all applications for appName, appDetails := range clientConfig.Applications &#123; fmt.Printf("Auth0 app: %s\\n", appName) client := getClient(domain, appDetails) jobResponse, err := createExportJob(domain, client) if err != nil &#123; return nil, fmt.Errorf("failed to create job: %w", err) &#125; jobStatus, err := pollExportJobStatus(domain, client, \*jobResponse) if err != nil &#123; return nil, fmt.Errorf("failed to retrieve job status: %w", err) &#125; // Download the file from the location URL fileResp, err := downloadFile(\*jobStatus) if err != nil &#123; return nil, fmt.Errorf("failed to download the exported file: %w", err) &#125; users, err := extractUsersFromFile(fileResp) if err != nil &#123; return nil, fmt.Errorf("failed to extract users from file: %w", err) &#125; allUsers = append(allUsers, users...) &#125; return allUsers, nil &#125; func getClientConfig() (\*Config, error) &#123; // Open and read the JSON file filePath := "./config/auth0-example-config.json" file, err := ioutil.ReadFile(filePath) if err != nil &#123; fmt.Printf("Error reading file: %s\\n", err) return nil, err &#125; // Unmarshal the JSON content into Config struct var config Config err = json.Unmarshal(file, &config) if err != nil &#123; fmt.Printf("Error unmarshalling JSON: %s\\n", err) return nil, err &#125; return &config, nil &#125; func getClient(domain string, appDetails Application) \*http.Client &#123; ctx := context.Background() clientConfig := clientcredentials.Config&#123; ClientID: appDetails.Auth0ClientID, ClientSecret: appDetails.Auth0ClientSecret, TokenURL: fmt.Sprintf("https://%s/oauth/token", domain), Scopes: \[\]string&#123;"read:users"&#125;, EndpointParams: map\[string\]\[\]string&#123; "audience": &#123;appDetails.Auth0Audience&#125;, &#125;, &#125; client := clientConfig.Client(ctx) return client &#125; func createExportJob(domain string, client \*http.Client) (\*JobResponse, error) &#123; jobRequest := ExportJobRequest&#123; Format: "json", Fields: \[\]Field&#123; &#123;Name: "app\_metadata"&#125;, &#123;Name: "blocked"&#125;, &#123;Name: "created\_at"&#125;, &#123;Name: "email"&#125;, &#123;Name: "email\_verified"&#125;, &#123;Name: "family\_name"&#125;, &#123;Name: "given\_name"&#125;, &#123;Name: "identities"&#125;, &#123;Name: "last\_ip"&#125;, &#123;Name: "last\_login"&#125;, &#123;Name: "logins\_count"&#125;, &#123;Name: "name"&#125;, &#123;Name: "nickname"&#125;, &#123;Name: "phone\_number"&#125;, &#123;Name: "phone\_verified"&#125;, &#123;Name: "picture"&#125;, &#123;Name: "updated\_at"&#125;, &#123;Name: "user\_id"&#125;, &#123;Name: "user\_metadata"&#125;, &#123;Name: "username"&#125;, // Add other fields as needed. &#125;, &#125; requestBody, \_ := json.Marshal(jobRequest) resp, err := client.Post(fmt.Sprintf("https://%s/api/v2/jobs/users-exports", domain), "application/json", bytes.NewBuffer(requestBody)) if err != nil &#123; return nil, fmt.Errorf("failed to start export job: %w", err) &#125; defer resp.Body.Close() var jobResponse JobResponse if err := json.NewDecoder(resp.Body).Decode(&jobResponse); err != nil &#123; return nil, fmt.Errorf("failed to decode job response: %w", err) &#125; return &jobResponse, nil &#125; func pollExportJobStatus(domain string, client \*http.Client, jobResponse JobResponse) (\*JobStatus, error) &#123; // Poll the job status until it's complete to get the file location var jobStatus JobStatus for &#123; time.Sleep(5 \* time.Second) // Wait before polling again jobStatusResp, \_ := client.Get(fmt.Sprintf("https://%s/api/v2/jobs/%s", domain, jobResponse.ID)) defer jobStatusResp.Body.Close() json.NewDecoder(jobStatusResp.Body).Decode(&jobStatus) if jobStatus.Status == "completed" && jobStatus.Location != "" &#123; fmt.Printf("File ready to download \\n") break &#125; &#125; return &jobStatus, nil &#125; func downloadFile(jobStatus JobStatus) (\*http.Response, error) &#123; fileResp, err := http.Get(jobStatus.Location) if err != nil &#123; return nil, fmt.Errorf("failed to download the exported file: %w", err) &#125; return fileResp, nil &#125; func extractUsersFromFile(fileResp \*http.Response) (\[\]User, error) &#123; defer fileResp.Body.Close() var reader io.Reader = fileResp.Body if strings.HasSuffix(fileResp.Request.URL.Path, ".gz") &#123; gzipReader, err := gzip.NewReader(fileResp.Body) if err != nil &#123; return nil, fmt.Errorf("failed to create gzip reader: %w", err) &#125; defer gzipReader.Close() reader = gzipReader &#125; var users \[\]User scanner := bufio.NewScanner(reader) for scanner.Scan() &#123; var user User if err := json.Unmarshal(scanner.Bytes(), &user); err != nil &#123; // Handle the error or log it, but don't necessarily return yet as other records might be valid fmt.Printf("Error parsing user record: %v\\n", err) continue &#125; users = append(users, user) &#125; if err := scanner.Err(); err != nil &#123; return nil, fmt.Errorf("error reading user records: %w", err) &#125; return users, nil &#125; ```

**Configuration Handling:**

*   Config **Struct:** Stores the **Auth0 domain** and **application credentials** (client ID, client secret, and audience) for multiple applications.
*   getClientConfig(): Reads a JSON configuration file containing Auth0 credentials and returns a Config object.

**User Export Process:**

Export Job Management:

*   ExportAuth0UsersJob():

The main function to **export all users from Auth0**. It follows these steps:

*   Loads the Auth0 **configuration**.
*   Iterates over each application in the configuration and:
    *   Initializes an **HTTP client** for Auth0.
    *   Creates an **export job** for each application.
    *   **Polls the job status** until it completes.
    *   **Downloads the exported file** once the job is completed.
    *   **Extracts user data** from the downloaded file and adds it to a consolidated user list.

*   createExportJob():

Creates a user export job on the Auth0 API by sending a **POST request**. It specifies the format (json) and the **user fields** to be included in the export.

*   pollExportJobStatus():

Continuously polls the Auth0 API for the **job’s status**. Once the status is marked as "completed", the function returns the **file location** for download.

Downloading and Extracting Users:

*   downloadFile():

Downloads the **exported user data** from the location provided in the job status.

*   extractUsersFromFile():

Reads the downloaded file (supports **GZIP compression**) and **parses user records** in JSON format. It uses a **scanner** to read the file line-by-line and unmarshals each user record into a User **struct**.

Auth0 Client Initialization:

*   getClient():

Creates an **OAuth2 HTTP client** using the **client credentials grant**. This client is used to communicate with the Auth0 API.

**Error Handling:**

*   **File Read Errors**: If the configuration file cannot be read, it prints the error and returns it.
*   **Job Status Errors**: If the job fails or the status check fails, it logs an error and returns.
*   **User Parsing Errors**: If individual user records fail to parse, it **logs the error** and continues parsing the remaining records.

#### **_Example your-auth0-users-passwords-exported.json_**

Credential in this file, if you use them, you can test the login using:

*   Username - dummy-1@example.com, Password - dummy-one@example.com
*   Username - dummy-2@example.com, Password - dummy-two@example.com
*   Username - dummy-3@example.com, Password - dummy-three@example.com

```text &#123; "\_id": &#123; "$oid": "65cae5bdbb371546863e5b6d" &#125;, "email": "dummy-1@example.com", "email\_verified": true, "tenant": "my-demo", "connection": "Username-Password-Authentication", "passwordHash": "$2y$10$xXuqs5YJksMuvYPtjjUowez97L2T4lLmS.oP5aHvb8SgAY/mLqfsq", "\_tmp\_is\_unique": true, "version": "1.1", "identifiers": \[ &#123; "type": "email", "value": "dummy-1@example.com", "verified": true &#125; \] &#125; &#123; "\_id": &#123; "$oid": "65c1b314efba7964db2cbb35" &#125;, "email": "dummy-2@example.com", "email\_verified": true, "tenant": "my-demo", "connection": "Username-Password-Authentication", "passwordHash": "$2y$10$D/Jbzci35tE4pdbbkqGjdOrdcQPU3lrDm1IWImP63AQwIXmwcE1SC", "\_tmp\_is\_unique": true, "version": "1.1", "identifiers": \[ &#123; "type": "email", "value": "dummy-2@example.com", "verified": true &#125; \] &#125; &#123; "\_id": &#123; "$oid": "65a9ae3127729943e0665e29" &#125;, "email": "dummy-3@example.com", "email\_verified": true, "tenant": "my-demo", "connection": "Username-Password-Authentication", "passwordHash": "$2y$10$xJ2Pi9M.pAP0L6CdoXL6cu/DBiOkBPN9VtVJL7ZreNeRa.Qi.hgwO", "\_tmp\_is\_unique": true, "version": "1.1", "identifiers": \[ &#123; "type": "email", "value": "dummy-3@example.com", "verified": true &#125; \] &#125; ```

#### **_convert\_auth0\_to\_local\_or\_firebase\_struct.go_**

This code is for **converting user objects**, **retrieving passwords** from a local file, and **mapping user identities** for seamless migration to Firebase. 

**Action:** replace "your-auth0-users-passwords-exported" with your exported filename.

**How It Works:**

*   **User Conversion:**
    *   The main conversion function, ConvertFromAuth0ToFirebaseUserToImport(), processes **Auth0 user data** and converts it to **Firebase-compatible** objects.
    *   **User identities** (providers) are converted and attached to each user.
*   **Password Handling:**
    *   **User passwords** are read from a **local JSON file**.
    *   Each user is matched with their password (if available), and the password hash is attached to the Firebase user object during conversion.
*   **Provider Data Transformation:**
    *   Auth0 user identities are mapped to either **Firebase providers** or a **local provider format**, depending on the function used.

```text package helpers import ( "bufio" "encoding/json" "firebase-admin-auth-api-poc/handlers/users/helpers" "firebase.google.com/go/v4/auth" "fmt" "os" ) // Auth0 Structures type Identity struct &#123; UserID string `json:"user\_id"` Provider string `json:"provider"` ProfileData map\[string\]interface&#123;&#125; `json:"profileData"` &#125; type User struct &#123; UserID string `json:"user\_id"` Email string `json:"email"` EmailVerified bool `json:"email\_verified"` Identities \[\]Identity `json:"identities"` Name string `json:"name"` Picture string `json:"picture"` UserMetadata map\[string\]interface&#123;&#125; `json:"user\_metadata"` &#125; type ExportJobRequest struct &#123; ConnectionID string `json:"connection\_id,omitempty"` // Optional Format string `json:"format"` Limit int `json:"limit,omitempty"` // Optional Fields \[\]Field `json:"fields"` &#125; type Field struct &#123; Name string `json:"name"` &#125; type UserPassword struct &#123; ID ID `json:"\_id"` EmailVerified bool `json:"email\_verified"` Email string `json:"email"` PasswordHash string `json:"passwordHash,omitempty"` Tenant string `json:"tenant"` Connection string `json:"connection"` TmpIsUnique bool `json:"\_tmp\_is\_unique"` Identifiers \[\]Identifier `json:"identifiers"` Version string `json:"version"` &#125; type ID struct &#123; Oid string `json:"$oid"` &#125; type Identifier struct &#123; Type string `json:"type"` Value string `json:"value"` Verified bool `json:"verified"` &#125; // Local Structures type UserToImport struct &#123; UID string `json:"uid,omitempty"` Email string `json:"email"` DisplayName string `json:"displayName"` PhotoURL string `json:"photoURL"` PhoneNumber string `json:"phoneNumber"` Metadata map\[string\]interface&#123;&#125; `json:"userMetadata,omitempty"` CustomClaims map\[string\]interface&#123;&#125; `json:"customClaims,omitempty"` Disabled bool `json:"disabled"` EmailVerified bool `json:"emailVerified"` ProviderData \[\]\*helpers.UserProvider `json:"userProviders,omitempty"` &#125; type UserAndMetadataToImport struct &#123; UserToImport \*auth.UserToImport `json:"userToImport"` Metadata map\[string\]interface&#123;&#125; `json:"userMetadata,omitempty"` &#125; func ConvertFromAuth0ToFirebaseUserToImport(users \[\]User) \[\]UserAndMetadataToImport &#123; var usersToImport \[\]UserAndMetadataToImport usersPasswords, err := getUsersPasswords() // Retrieve passwords once if err != nil &#123; fmt.Printf("Unable to get users passwords: %s\\n", err) return nil // Or handle the error more gracefully &#125; for \_, u := range users &#123; userImport := (&auth.UserToImport&#123;&#125;). UID(u.UserID). Email(u.Email). DisplayName(u.Name). PhotoURL(u.Picture). EmailVerified(u.EmailVerified). PasswordHash(getPasswordHashForUser(u, usersPasswords)). // Use the safely obtained passwordHash ProviderData(ConvertFromAuth0ToFirebaseUserProviders(u.Identities)) metadata := u.UserMetadata usersToImport = append(usersToImport, UserAndMetadataToImport&#123; UserToImport: userImport, Metadata: metadata, &#125;) &#125; return usersToImport &#125; func ConvertFromAuth0ToLocalUserToImport(users \[\]User) \[\]\*UserToImport &#123; var usersToImport \[\]\*UserToImport for \_, u := range users &#123; userImport := UserToImport&#123; UID: u.UserID, Email: u.Email, DisplayName: u.Name, PhotoURL: u.Picture, EmailVerified: u.EmailVerified, ProviderData: ConvertFromAuth0ToLocalUserProviders(u.Identities), &#125; // TODO set Metadata usersToImport = append(usersToImport, &userImport) &#125; return usersToImport &#125; func ConvertFromAuth0ToFirebaseUserProviders(identities \[\]Identity) \[\]\*auth.UserProvider &#123; var providerData \[\]\*auth.UserProvider // Construct the slice of providers here for \_, identity := range identities &#123; provider := helpers.UserProvider&#123; UID: identity.UserID, ProviderID: identity.Provider, &#125; if email, ok := identity.ProfileData\["email"\].(string); ok &#123; provider.Email = email &#125; // Append the converted provider to the slice providerData = append(providerData, helpers.ConvertToFirebaseUserProvider(&provider)) &#125; return providerData &#125; func ConvertFromAuth0ToLocalUserProviders(identities \[\]Identity) \[\]\*helpers.UserProvider &#123; var providerData \[\]\*helpers.UserProvider // Construct the slice of providers here for \_, identity := range identities &#123; provider := helpers.UserProvider&#123; UID: identity.UserID, ProviderID: identity.Provider, &#125; if email, ok := identity.ProfileData\["email"\].(string); ok &#123; provider.Email = email &#125; // Append the converted provider to the slice providerData = append(providerData, &provider) &#125; return providerData &#125; func getUsersPasswords() (\[\]UserPassword, error) &#123; // Open the JSON file filePath := "./data/your-auth0-users-passwords-exported.json" file, err := os.Open(filePath) if err != nil &#123; fmt.Printf("Error opening file: %s\\n", err) return nil, err &#125; defer file.Close() var userPasswords \[\]UserPassword scanner := bufio.NewScanner(file) // Read and unmarshal each line (JSON object) into the slice for scanner.Scan() &#123; var userPassword UserPassword err := json.Unmarshal(scanner.Bytes(), &userPassword) if err != nil &#123; fmt.Printf("Error unmarshalling user password JSON: %s\\n", err) // Decide how to handle errors; you might continue, return, or collect errors return nil, err &#125; userPasswords = append(userPasswords, userPassword) &#125; if err := scanner.Err(); err != nil &#123; fmt.Printf("Error reading file: %s\\n", err) return nil, err &#125; return userPasswords, nil &#125; func findUserPassword(user User, usersPasswords \[\]UserPassword) \*UserPassword &#123; for \_, userPassword := range usersPasswords &#123; if userPassword.Email == user.Email &#123; return &userPassword &#125; &#125; return nil &#125; func getPasswordHashForUser(user User, users \[\]UserPassword) \[\]byte &#123; userPassword := findUserPassword(user, users) // Correctly use the result // fmt.Println("Email: ", u.Email, " Password: ", userPassword.PasswordHash, " Connection: ", userPassword.Connection) var passwordHash \[\]byte if userPassword != nil && userPassword.PasswordHash != "" &#123; passwordHash = \[\]byte(userPassword.PasswordHash) &#125; else &#123; fmt.Println("No password found or userPassword is nil") // fmt.Println("No password found or userPassword is nil for Email ", u.Email, " and connection ", userPassword.Connection) &#125; return passwordHash &#125; ```

**Auth0 User Structures:**

*   Identity: Represents a user identity from an external provider (e.g., Google, Facebook) with associated profile data.
*   User: Represents an **Auth0 user** with properties such as user\_id, email, name, and associated metadata.

**User Conversion Functions:**

*   ConvertFromAuth0ToFirebaseUserToImport():
    *   Converts **Auth0 users to Firebase-compatible users**.
    *   It also **retrieves user passwords** and assigns them using getPasswordHashForUser().
    *   For each user, it **transforms their provider data** (e.g., Google, Facebook) into Firebase’s provider format.
*   ConvertFromAuth0ToLocalUserToImport():
    *   Converts Auth0 users into a **local format** (UserToImport), which can be used for Firebase imports.
    *   Sets basic fields such as UID, Email, and DisplayName.

**User Provider Conversion:**

*   ConvertFromAuth0ToFirebaseUserProviders():
    *   Converts **Auth0 user identities** to **Firebase providers**.
    *   Maps properties like user\_id and provider into a format Firebase understands.
*   ConvertFromAuth0ToLocalUserProviders():
    *   Converts Auth0 identities into a **local provider format** (UserProvider), which is used when importing users locally.

**Password Handling:**

*   getUsersPasswords():
    *   Reads a **JSON file** containing user passwords from the local filesystem.
    *   Parses the file line-by-line, unmarshaling each line into a UserPassword struct.
*   findUserPassword():
    *   Searches for a user’s password by matching the email address in the **password records**.
*   getPasswordHashForUser():
    *   Retrieves the **password hash** for a given user.
    *   If no password is found, it prints an appropriate message and returns an empty hash.

**Data Structures for Firebase Migration:**

*   UserToImport: Represents a user object for Firebase import with fields like UID, Email, PhotoURL, and PhoneNumber.
*   UserAndMetadataToImport: A wrapper structure combining **user import data** and associated **metadata**.

**Error Handling:**

*   **Password File Errors:** If the password file fails to open or parse, an error message is printed, and the function exits gracefully.
*   **User Parsing Errors:** If a user’s password or identity data fails to parse, the code logs the error and continues processing other users.

To log in and test the credentials migrated across you will need to have a client that connects to the tenants, this blog post does not contain the instructions to configure that, however you can look at [https://github.com/firebase/firebaseui-web](https://github.com/firebase/firebaseui-web) for a starting point to help you establish a client for quick validation of your data.

## Did this help?

*   **Like, comment and share this article**
*   **Follow this blog** to receive notifications of new postings
*   **View** [previous postings](https://robertleggett.blog/)
