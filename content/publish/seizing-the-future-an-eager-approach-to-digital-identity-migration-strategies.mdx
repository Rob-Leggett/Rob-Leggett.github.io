---
title: "Seizing the Future - An Eager Approach to Digital Identity Migration Strategies"
date: "2024-10-17"
slug: "seizing-the-future-an-eager-approach-to-digital-identity-migration-strategies"
status: "publish"
feature_image: "/blog/seizing-the-future-an-eager-approach-to-digital-identity-migration-strategies/feature-image.png"
---

In today's digital age, managing digital identities efficiently and securely has become a cornerstone for any online platform. Among the various strategies to upgrade or shift digital identity management systems, two approaches stand out: **Eager Migration** and **Lazy Migration**, each with its unique advantages and challenges. In this exploration, we delve into the nuances, particularly focusing on the proactive stance of Eager Migration.

## Before you start

About this post:

- 5–10 min average reading time
- Suitable for intermediate through to advanced readers

What you will gain reading this post:

- An overview of migration strategies
- A guide on choosing the best approach to support your solution

What you can do to help support:

- **Like, comment and share this article**
- **Follow this blog** to receive notifications of new postings

Now, let's get started.

---

## Migration Strategies

When transitioning to a new identity platform or system, choosing the right migration strategy is essential to ensure minimal disruption and optimal user experience. Two primary strategies are **Eager Migration** and **Lazy Migration**.

### Eager Migration

Eager Migration represents a proactive and decisive approach, transferring all user accounts and associated data to the new system in a single, large-scale migration before any user interaction is required.

**Advantages:**

- **Immediate Consistency:** All users are migrated simultaneously, ensuring system-wide consistency and eliminating version discrepancies.
- **Enhanced User Experience:** Users seamlessly access the new system without needing to take any action, such as re-registering or re-authenticating.
- **Predictable Rollout:** The migration is carefully planned and executed, reducing risks of unexpected user issues post-launch.
- **Simplified Support:** Customer support teams can focus solely on the new system.

**Challenges:**

- **High Complexity and Risk:** Large-scale migrations require precise coordination and testing. Any error can affect all users.
- **Downtime Risk:** The system might require a maintenance window during migration.
- **Resource Intensive:** Requires significant upfront investment in planning and execution.

Eager migration is ideal for platforms prioritizing consistency and control, especially when maintaining multiple systems would be costly or impractical.

---

### Lazy Migration

Lazy Migration takes a gradual approach. Accounts are transferred only when users engage with the system (e.g., during login).

**Advantages:**

- **Minimized Initial Risk:** Avoids a single massive migration event.
- **Resource Optimization:** Migrates users in smaller batches.
- **Less Downtime:** Minimal disruption for end users.
- **User Self-Management:** Users trigger their own migration naturally.

**Challenges:**

- **Fragmented State:** Some users remain on the old system while others move to the new one.
- **User Experience Dependency:** Relies on user interaction to complete migration.
- **Support Complexity:** Support teams must manage both systems.
- **Longer Transition:** Full migration can take weeks or months.

Lazy migration works well when availability is critical and user-driven transitions are acceptable.

---

## Eager Migration: A Proactive Leap Forward

Eager Migration represents a bold strategy for transitioning user accounts before any login is required — ensuring **immediate system-wide consistency** and a **seamless experience**.

### The Promise of Uniformity

By migrating everyone upfront, platforms guarantee a consistent experience for all users. This eliminates staggered transition periods and provides frictionless integration across environments.

### The Eager Migration Path

#### 1. Dividing Users into Tenants

When supporting multi-tenancy, users can be sorted by email domain into corresponding tenants for better management.

#### 2. Streamlining Sign-On Processes

Eager migration retains familiar credentials, minimizing friction for users post-migration.

#### 3. Finalizing the Move

A final validation ensures all users have been migrated successfully and that accounts function as expected.

#### 4. Challenges and Considerations

Despite its advantages, this approach demands careful planning and attention to data compatibility, user privacy, and authentication methods such as bcrypt password hashes.

---

## Working Example: Migrating from Auth0 to GCP Identity Platform

### **main.go**

This example supports both **global** and **tenant-specific** user migrations.
It runs on `http://localhost:8080` with CORS enabled and exposes two endpoints:

- `GET /migration/auth0/export-import-users`
- `GET /migration/auth0/tenant/{tenantId}/export-import-users`

The design allows migration of users specific to a **tenant**, identified by &#123;tenantId&#125; in the URL. Both routes respond to **GET** and **OPTIONS** requests.

```go
package main

import (
  "firebase-admin-auth-api-poc/handlers/auth0"
  "firebase-admin-auth-api-poc/handlers/middleware/cors"
  "firebase-admin-auth-api-poc/util"
  firebase "firebase.google.com/go/v4"
  "fmt"
  "github.com/gorilla/mux"
  "log"
  "net/http"
)

func main() {
  fm := util.NewFirebaseManager()
  router := mux.NewRouter()
  configureMigration(router, fm)

  fmt.Println("Server started on :8080")
  log.Fatal(http.ListenAndServe(":8080", cors.EnableCORS(router.ServeHTTP)))
}

func configureMigration(router *mux.Router, fm *firebase.App) {
  router.HandleFunc("/migration/auth0/export-import-users", auth0.ExportImportUsersHandler(fm)).Methods("GET", "OPTIONS")
  router.HandleFunc("/migration/auth0/tenant/{tenantId}/export-import-users", auth0.ExportImportUsersHandler(fm)).Methods("GET", "OPTIONS")
}
```

#### **_export_import_users.go**

This code provides an HTTP API endpoint to **migrate users from Auth0 to Firebase**. It ensures that users are seamlessly exported from Auth0, converted into a Firebase-compatible format, and imported into the specified Firebase tenant. It also **handles common errors** like missing tenant IDs and import failures, and limits imports to **1000 users per batch** to comply with GCP Identity Platform’s constraints.

```go
package auth0

import (
  "encoding/json"
  "firebase-admin-auth-api-poc/handlers/auth0/helpers"
  u "firebase-admin-auth-api-poc/handlers/users"
  "firebase-admin-auth-api-poc/util"
  firebase "firebase.google.com/go/v4"
  "firebase.google.com/go/v4/auth"
  "fmt"
  "github.com/gorilla/mux"
  "net/http"
)

type ExportImportResults struct {
  Users   []*helpers.UserToImport     `json:"users"`
  Results *auth.UserImportResult      `json:"results"`
}

func ExportImportUsersHandler(fm *firebase.App) func(w http.ResponseWriter, r *http.Request) {
  return func(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    tenantId := vars["tenantId"]
    if tenantId == "" {
      http.Error(w, "Unable to get tenant id", http.StatusBadRequest)
      return
    }

    users, err := exportAuth0Users()
    if err != nil {
      http.Error(w, "Error exporting Auth0 users", http.StatusInternalServerError)
      return
    }

    tc, err := util.GetTenantClient(fm, tenantId)
    if err != nil {
      http.Error(w, "Unable to get tenant client", http.StatusInternalServerError)
      return
    }

    importedResults, err := importAuth0Users(tc, users)
    if err != nil {
      http.Error(w, "Error importing users", http.StatusInternalServerError)
      return
    }

    response := generateResponse(users, importedResults)
    w.Header().Set("Content-Type", "application/json")
    if err := json.NewEncoder(w).Encode(response); err != nil {
      http.Error(w, "Error encoding users to JSON", http.StatusInternalServerError)
    }
  }
}
```
**Struct Definition:**

*   ExportImportResults: Holds the user data and the import results for the response.

**HTTP Handler:**

*   ExportImportUsersHandler(fm \*firebase.App): This function returns an HTTP handler that coordinates the **export and import of users** between Auth0 and Firebase.

**Workflow:**

*   Extracts the tenantId from the request path.
*   Exports users from Auth0 using exportAuth0Users().
*   Gets a Firebase tenant client for the given tenantId using util.GetTenantClient().
*   Imports the exported users into Firebase using importAuth0Users().
*   Generates and sends the response in **JSON** format with the import results.

Exporting Users from Auth0:

*   exportAuth0Users(): Calls a helper function ExportAuth0UsersJob() to retrieve users from Auth0.

Importing Users into Firebase:

*   importAuth0Users(tc \*auth.TenantClient, users \[\]helpers.User):
*   Converts Auth0 users to Firebase-compatible user objects.
*   Imports users into Firebase, with a **reminder to handle import limits (1000 users per batch)** if necessary.

Generating the Response:

*   generateResponse(): Prepares a response containing both the exported users and the import results.

**Error Handling:**

*   If there are **missing tenant IDs**, or **export/import failures**, appropriate **HTTP error responses** are returned.
*   Uses http.Error() to send error messages in case of issues during processing.

#### **Example auth0-example-config.json**

```json
{
  "auth0domain": "REPLACE_WITH_AUTH0_DOMAIN",
  "applications": {
    "Auth0 Management API": {
      "auth0clientID": "REPLACE_WITH_CLIENT_ID",
      "auth0clientsecret": "REPLACE_WITH_CLIENT_SECRET",
      "auth0audience": "https://REPLACE_WITH_AUTH0_DOMAIN/api/v2/"
    }
  }
}
```

#### **auth0.go**

This code is for exporting user data from **Auth0**. It provides functions to initiate, monitor, and download the user export job from Auth0, and it processes the exported data for further use.

**Reference:** Export User Passwords from Auth0 - [https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data)

**How It Works:**

*   **Configuration Handling:**
    *   Loads **Auth0 credentials** from a local JSON file.
*   **User Export Process**:
    *   For each configured Auth0 application:
        *   **Creates an export job** through the Auth0 API.
        *   **Polls the job status** until it completes.
        *   **Downloads the exported file** from the provided location.
        *   **Extracts user data** from the file.
        *   **Handling GZIP Compression**:
            *   If the downloaded file is GZIP-compressed, it decompresses it before extracting the user records.

```go
// helpers/auth0.go
package helpers

import (
	"bufio"
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"fmt"
	"golang.org/x/oauth2/clientcredentials"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

// -----------------------------------------------------------------------------
// Configuration
// -----------------------------------------------------------------------------

// Config is the structure of ./config/auth0-example-config.json
type Config struct {
	Auth0Domain string                 `json:"auth0domain"`
	Applications map[string]Application `json:"applications"`
}

type Application struct {
	Auth0ClientID     string `json:"auth0clientID"`
	Auth0ClientSecret string `json:"auth0clientsecret"`
	Auth0Audience     string `json:"auth0audience"`
}

// getClientConfig reads the JSON config file that holds the Auth0 tenant and app creds.
func getClientConfig() (*Config, error) {
	filePath := "./config/auth0-example-config.json"
	b, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("read config: %w", err)
	}
	var c Config
	if err := json.Unmarshal(b, &c); err != nil {
		return nil, fmt.Errorf("unmarshal config: %w", err)
	}
	if c.Auth0Domain == "" || len(c.Applications) == 0 {
		return nil, fmt.Errorf("invalid config: missing domain or applications")
	}
	return &c, nil
}

// getClient builds an OAuth2 client (Client Credentials flow) for a given app.
func getClient(domain string, app Application) *http.Client {
	ctx := context.Background()
	cfg := clientcredentials.Config{
		ClientID:     app.Auth0ClientID,
		ClientSecret: app.Auth0ClientSecret,
		TokenURL:     fmt.Sprintf("https://%s/oauth/token", domain),
		Scopes:       []string{"read:users"},
		EndpointParams: map[string][]string{
			"audience": {app.Auth0Audience},
		},
	}
	return cfg.Client(ctx)
}

// -----------------------------------------------------------------------------
// Auth0 User Export Job API (minimal surface for exports)
// -----------------------------------------------------------------------------

// ExportJobRequest describes the fields to include in the export.
type ExportJobRequest struct {
	ConnectionID string  `json:"connection_id,omitempty"`
	Format       string  `json:"format"`           // "json"
	Limit        int     `json:"limit,omitempty"`  // optional
	Fields       []Field `json:"fields"`           // which fields to export
}

type Field struct {
	Name string `json:"name"`
}

type JobResponse struct {
	ID string `json:"id"`
}

type JobStatus struct {
	Status   string `json:"status"`
	Location string `json:"location,omitempty"`
}

// createExportJob requests a new users-exports job.
func createExportJob(domain string, client *http.Client) (*JobResponse, error) {
	req := ExportJobRequest{
		Format: "json",
		Fields: []Field{
			{Name: "app_metadata"},
			{Name: "blocked"},
			{Name: "created_at"},
			{Name: "email"},
			{Name: "email_verified"},
			{Name: "family_name"},
			{Name: "given_name"},
			{Name: "identities"},
			{Name: "last_ip"},
			{Name: "last_login"},
			{Name: "logins_count"},
			{Name: "name"},
			{Name: "nickname"},
			{Name: "phone_number"},
			{Name: "phone_verified"},
			{Name: "picture"},
			{Name: "updated_at"},
			{Name: "user_id"},
			{Name: "user_metadata"},
			{Name: "username"},
		},
	}
	body, _ := json.Marshal(req)

	resp, err := client.Post(
		fmt.Sprintf("https://%s/api/v2/jobs/users-exports", domain),
		"application/json",
		bytes.NewBuffer(body),
	)
	if err != nil {
		return nil, fmt.Errorf("start export job: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		b, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("start export job: status %d body: %s", resp.StatusCode, string(b))
	}

	var jr JobResponse
	if err := json.NewDecoder(resp.Body).Decode(&jr); err != nil {
		return nil, fmt.Errorf("decode job response: %w", err)
	}
	return &jr, nil
}

// pollExportJobStatus blocks until the export job finishes and returns the download URL.
func pollExportJobStatus(domain string, client *http.Client, jr JobResponse) (*JobStatus, error) {
	var js JobStatus
	for {
		time.Sleep(5 * time.Second)
		resp, err := client.Get(fmt.Sprintf("https://%s/api/v2/jobs/%s", domain, jr.ID))
		if err != nil {
			return nil, fmt.Errorf("poll job: %w", err)
		}
		func() {
			defer resp.Body.Close()
			_ = json.NewDecoder(resp.Body).Decode(&js)
		}()

		if js.Status == "completed" && js.Location != "" {
			return &js, nil
		}
		if js.Status == "failed" {
			return nil, fmt.Errorf("export job failed")
		}
	}
}

// downloadFile fetches the exported file (could be .json or .json.gz).
func downloadFile(js JobStatus) (*http.Response, error) {
	resp, err := http.Get(js.Location)
	if err != nil {
		return nil, fmt.Errorf("download export: %w", err)
	}
	if resp.StatusCode >= 300 {
		b, _ := io.ReadAll(resp.Body)
		_ = resp.Body.Close()
		return nil, fmt.Errorf("download export: status %d body: %s", resp.StatusCode, string(b))
	}
	return resp, nil
}

// -----------------------------------------------------------------------------
// Data models & extraction
// -----------------------------------------------------------------------------

// Identity as returned inside the exported user JSON lines.
type Identity struct {
	UserID      string                 `json:"user_id"`
	Provider    string                 `json:"provider"`
	ProfileData map[string]interface{} `json:"profileData"`
}

// User represents the subset we care about from Auth0 export.
type User struct {
	UserID        string                 `json:"user_id"`
	Email         string                 `json:"email"`
	EmailVerified bool                   `json:"email_verified"`
	Identities    []Identity             `json:"identities"`
	Name          string                 `json:"name"`
	Picture       string                 `json:"picture"`
	UserMetadata  map[string]interface{} `json:"user_metadata"`
}

// extractUsersFromFile reads line-delimited JSON (.json or .json.gz) into []User.
func extractUsersFromFile(fileResp *http.Response) ([]User, error) {
	defer fileResp.Body.Close()

	var reader io.Reader = fileResp.Body
	// Detect gzip by URL suffix or content type header
	if strings.HasSuffix(strings.ToLower(fileResp.Request.URL.Path), ".gz") ||
		strings.Contains(strings.ToLower(fileResp.Header.Get("Content-Type")), "gzip") {
		gz, err := gzip.NewReader(fileResp.Body)
		if err != nil {
			return nil, fmt.Errorf("gzip reader: %w", err)
		}
		defer gz.Close()
		reader = gz
	}

	sc := bufio.NewScanner(reader)
	// Bump scanner buffer for large JSON lines.
	const maxLine = 10 * 1024 * 1024 // 10MB per line
	buf := make([]byte, 64*1024)
	sc.Buffer(buf, maxLine)

	var out []User
	for sc.Scan() {
		line := sc.Bytes()
		// Trim whitespace to be safe
		line = bytes.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		var u User
		if err := json.Unmarshal(line, &u); err != nil {
			// Log and continue instead of failing the whole batch
			fmt.Printf("WARN: skipping malformed user record: %v\n", err)
			continue
		}
		out = append(out, u)
	}
	if err := sc.Err(); err != nil {
		return nil, fmt.Errorf("scan exported users: %w", err)
	}
	return out, nil
}

// -----------------------------------------------------------------------------
// High-level: export all users across configured applications
// -----------------------------------------------------------------------------

// ExportAuth0UsersJob executes an export job for each configured app and aggregates users.
func ExportAuth0UsersJob() ([]User, error) {
	cfg, err := getClientConfig()
	if err != nil {
		return nil, fmt.Errorf("config: %w", err)
	}
	domain := cfg.Auth0Domain

	var all []User
	for appName, app := range cfg.Applications {
		fmt.Printf("Auth0 app: %s\n", appName)

		client := getClient(domain, app)

		jr, err := createExportJob(domain, client)
		if err != nil {
			return nil, fmt.Errorf("create job: %w", err)
		}

		js, err := pollExportJobStatus(domain, client, *jr)
		if err != nil {
			return nil, fmt.Errorf("poll job: %w", err)
		}

		resp, err := downloadFile(*js)
		if err != nil {
			return nil, fmt.Errorf("download export: %w", err)
		}

		users, err := extractUsersFromFile(resp)
		if err != nil {
			return nil, fmt.Errorf("extract users: %w", err)
		}

		all = append(all, users...)
	}
	return all, nil
}
```

**Configuration Handling:**

*   Config **Struct:** Stores the **Auth0 domain** and **application credentials** (client ID, client secret, and audience) for multiple applications.
*   getClientConfig(): Reads a JSON configuration file containing Auth0 credentials and returns a Config object.

**User Export Process:**

Export Job Management:

*   ExportAuth0UsersJob():

The main function to **export all users from Auth0**. It follows these steps:

*   Loads the Auth0 **configuration**.
*   Iterates over each application in the configuration and:
    *   Initializes an **HTTP client** for Auth0.
    *   Creates an **export job** for each application.
    *   **Polls the job status** until it completes.
    *   **Downloads the exported file** once the job is completed.
    *   **Extracts user data** from the downloaded file and adds it to a consolidated user list.

*   createExportJob():

Creates a user export job on the Auth0 API by sending a **POST request**. It specifies the format (json) and the **user fields** to be included in the export.

*   pollExportJobStatus():

Continuously polls the Auth0 API for the **job’s status**. Once the status is marked as "completed", the function returns the **file location** for download.

Downloading and Extracting Users:

*   downloadFile():

Downloads the **exported user data** from the location provided in the job status.

*   extractUsersFromFile():

Reads the downloaded file (supports **GZIP compression**) and **parses user records** in JSON format. It uses a **scanner** to read the file line-by-line and unmarshals each user record into a User **struct**.

Auth0 Client Initialization:

*   getClient():

Creates an **OAuth2 HTTP client** using the **client credentials grant**. This client is used to communicate with the Auth0 API.

**Error Handling:**

*   **File Read Errors**: If the configuration file cannot be read, it prints the error and returns it.
*   **Job Status Errors**: If the job fails or the status check fails, it logs an error and returns.
*   **User Parsing Errors**: If individual user records fail to parse, it **logs the error** and continues parsing the remaining records.

#### **Example your-auth0-users-passwords-exported.json**

Credential in this file, if you use them, you can test the login using:

*   Username - dummy-1@example.com, Password - dummy-one@example.com
*   Username - dummy-2@example.com, Password - dummy-two@example.com
*   Username - dummy-3@example.com, Password - dummy-three@example.com

```json
{
  "_id": { "$oid": "65cae5bdbb371546863e5b6d" },
  "email": "dummy-1@example.com",
  "email_verified": true,
  "tenant": "my-demo",
  "connection": "Username-Password-Authentication",
  "passwordHash": "$2y$10$xXuqs5YJksMuvYPtjjUowez97L2T4lLmS.oP5aHvb8SgAY/mLqfsq"
}
```

#### **convert_auth0_to_local_or_firebase_struct.go**

This code is for **converting user objects**, **retrieving passwords** from a local file, and **mapping user identities** for seamless migration to Firebase. 

**Action:** replace "your-auth0-users-passwords-exported" with your exported filename.

**How It Works:**

*   **User Conversion:**
    *   The main conversion function, ConvertFromAuth0ToFirebaseUserToImport(), processes **Auth0 user data** and converts it to **Firebase-compatible** objects.
    *   **User identities** (providers) are converted and attached to each user.
*   **Password Handling:**
    *   **User passwords** are read from a **local JSON file**.
    *   Each user is matched with their password (if available), and the password hash is attached to the Firebase user object during conversion.
*   **Provider Data Transformation:**
    *   Auth0 user identities are mapped to either **Firebase providers** or a **local provider format**, depending on the function used.

```go
// helpers/convert_auth0_to_local_or_firebase_struct.go
package helpers

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"

	fbauth "firebase.google.com/go/v4/auth"
)

// -----------------------------------------------------------------------------
// Local mirror structures (matching what you described earlier)
// -----------------------------------------------------------------------------

// For password lookup file (JSON Lines format)
type UserPassword struct {
	ID           ID          `json:"_id"`
	EmailVerified bool       `json:"email_verified"`
	Email        string      `json:"email"`
	PasswordHash string      `json:"passwordHash,omitempty"`
	Tenant       string      `json:"tenant"`
	Connection   string      `json:"connection"`
	TmpIsUnique  bool        `json:"_tmp_is_unique"`
	Identifiers  []Identifier `json:"identifiers"`
	Version      string      `json:"version"`
}

type ID struct {
	Oid string `json:"$oid"`
}

type Identifier struct {
	Type     string `json:"type"`
	Value    string `json:"value"`
	Verified bool   `json:"verified"`
}

// Local format you wanted to expose (if needed for debugging/preview)
type UserToImport struct {
	UID          string                 `json:"uid,omitempty"`
	Email        string                 `json:"email"`
	DisplayName  string                 `json:"displayName"`
	PhotoURL     string                 `json:"photoURL"`
	PhoneNumber  string                 `json:"phoneNumber"`
	Metadata     map[string]interface{} `json:"userMetadata,omitempty"`
	CustomClaims map[string]interface{} `json:"customClaims,omitempty"`
	Disabled     bool                   `json:"disabled"`
	EmailVerified bool                  `json:"emailVerified"`
	ProviderData []*UserProvider        `json:"userProviders,omitempty"`
}

// When importing to Firebase Admin SDK we’ll pair the *auth.UserToImport with metadata
type UserAndMetadataToImport struct {
	UserToImport *fbauth.UserToImport    `json:"userToImport"`
	Metadata     map[string]interface{}  `json:"userMetadata,omitempty"`
}

// -----------------------------------------------------------------------------
// Provider mapping
// -----------------------------------------------------------------------------

// Minimal provider mirror so we can transform to Firebase's *auth.UserProvider.
type UserProvider struct {
	UID        string `json:"uid,omitempty"`
	ProviderID string `json:"providerId,omitempty"`
	Email      string `json:"email,omitempty"`
}

// ConvertToFirebaseUserProvider converts our local provider into Firebase's type.
func ConvertToFirebaseUserProvider(p *UserProvider) *fbauth.UserProvider {
	if p == nil {
		return nil
	}
	out := &fbauth.UserProvider{
		UID:       p.UID,
		ProviderID: p.ProviderID,
		Email:     p.Email,
	}
	return out
}

// -----------------------------------------------------------------------------
// Converters from exported Auth0 users -> Firebase import payloads
// -----------------------------------------------------------------------------

// ConvertFromAuth0ToFirebaseUserToImport builds Firebase import payloads
// and pairs them with user metadata so you can store metadata separately (if desired).
func ConvertFromAuth0ToFirebaseUserToImport(users []User) []UserAndMetadataToImport {
	var result []UserAndMetadataToImport

	// Load password hashes once
	userPasswords, err := getUsersPasswords("./data/your-auth0-users-passwords-exported.json")
	if err != nil {
		fmt.Printf("WARN: unable to read password export file: %v\n", err)
	}

	for _, u := range users {
		passHash := getPasswordHashForUser(u, userPasswords)

		userImport := (&fbauth.UserToImport{}).
			UID(u.UserID).
			Email(u.Email).
			DisplayName(u.Name).
			PhotoURL(u.Picture).
			EmailVerified(u.EmailVerified).
			PasswordHash(passHash).
			ProviderData(ConvertFromAuth0ToFirebaseUserProviders(u.Identities))

		result = append(result, UserAndMetadataToImport{
			UserToImport: userImport,
			Metadata:     u.UserMetadata,
		})
	}
	return result
}

// ConvertFromAuth0ToLocalUserToImport returns a simplified local preview object.
func ConvertFromAuth0ToLocalUserToImport(users []User) []*UserToImport {
	var out []*UserToImport
	for _, u := range users {
		lu := &UserToImport{
			UID:          u.UserID,
			Email:        u.Email,
			DisplayName:  u.Name,
			PhotoURL:     u.Picture,
			EmailVerified: u.EmailVerified,
			ProviderData: ConvertFromAuth0ToLocalUserProviders(u.Identities),
		}
		out = append(out, lu)
	}
	return out
}

// ConvertFromAuth0ToFirebaseUserProviders converts Auth0 identities to Firebase providers.
func ConvertFromAuth0ToFirebaseUserProviders(identities []Identity) []*fbauth.UserProvider {
	var out []*fbauth.UserProvider
	for _, id := range identities {
		p := &UserProvider{
			UID:        id.UserID,
			ProviderID: id.Provider,
		}
		if email, ok := id.ProfileData["email"].(string); ok {
			p.Email = email
		}
		out = append(out, ConvertToFirebaseUserProvider(p))
	}
	return out
}

// ConvertFromAuth0ToLocalUserProviders converts Auth0 identities to our local provider type.
func ConvertFromAuth0ToLocalUserProviders(identities []Identity) []*UserProvider {
	var out []*UserProvider
	for _, id := range identities {
		p := &UserProvider{
			UID:        id.UserID,
			ProviderID: id.Provider,
		}
		if email, ok := id.ProfileData["email"].(string); ok {
			p.Email = email
		}
		out = append(out, p)
	}
	return out
}

// -----------------------------------------------------------------------------
// Password file (JSON Lines) helpers
// -----------------------------------------------------------------------------

// getUsersPasswords reads a line-delimited JSON file of UserPassword entries.
func getUsersPasswords(filePath string) ([]UserPassword, error) {
	f, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("open password file: %w", err)
	}
	defer f.Close()

	sc := bufio.NewScanner(f)
	// up the scanner buffer for long JSON lines
	const maxLine = 10 * 1024 * 1024
	buf := make([]byte, 64*1024)
	sc.Buffer(buf, maxLine)

	var out []UserPassword
	for sc.Scan() {
		line := sc.Bytes()
		if len(line) == 0 {
			continue
		}
		var up UserPassword
		if err := json.Unmarshal(line, &up); err != nil {
			fmt.Printf("WARN: skipping bad password line: %v\n", err)
			continue
		}
		out = append(out, up)
	}
	if err := sc.Err(); err != nil {
		return nil, fmt.Errorf("scan password file: %w", err)
	}
	return out, nil
}

// findUserPassword finds a password record by email.
func findUserPassword(user User, usersPasswords []UserPassword) *UserPassword {
	for i := range usersPasswords {
		if usersPasswords[i].Email == user.Email {
			return &usersPasswords[i]
		}
	}
	return nil
}

// getPasswordHashForUser returns the bcrypt hash bytes to pass to Firebase import.
func getPasswordHashForUser(user User, users []UserPassword) []byte {
	up := findUserPassword(user, users)
	if up != nil && up.PasswordHash != "" {
		return []byte(up.PasswordHash)
	}
	// no hash known for this user — return nil (Firebase will import without password)
	fmt.Printf("INFO: no password hash for %s\n", user.Email)
	return nil
}
```

**Auth0 User Structures:**

*   Identity: Represents a user identity from an external provider (e.g., Google, Facebook) with associated profile data.
*   User: Represents an **Auth0 user** with properties such as user_id, email, name, and associated metadata.

**User Conversion Functions:**

*   ConvertFromAuth0ToFirebaseUserToImport():
    *   Converts **Auth0 users to Firebase-compatible users**.
    *   It also **retrieves user passwords** and assigns them using getPasswordHashForUser().
    *   For each user, it **transforms their provider data** (e.g., Google, Facebook) into Firebase’s provider format.
*   ConvertFromAuth0ToLocalUserToImport():
    *   Converts Auth0 users into a **local format** (UserToImport), which can be used for Firebase imports.
    *   Sets basic fields such as UID, Email, and DisplayName.

**User Provider Conversion:**

*   ConvertFromAuth0ToFirebaseUserProviders():
    *   Converts **Auth0 user identities** to **Firebase providers**.
    *   Maps properties like user_id and provider into a format Firebase understands.
*   ConvertFromAuth0ToLocalUserProviders():
    *   Converts Auth0 identities into a **local provider format** (UserProvider), which is used when importing users locally.

**Password Handling:**

*   getUsersPasswords():
    *   Reads a **JSON file** containing user passwords from the local filesystem.
    *   Parses the file line-by-line, unmarshaling each line into a UserPassword struct.
*   findUserPassword():
    *   Searches for a user’s password by matching the email address in the **password records**.
*   getPasswordHashForUser():
    *   Retrieves the **password hash** for a given user.
    *   If no password is found, it prints an appropriate message and returns an empty hash.

**Data Structures for Firebase Migration:**

*   UserToImport: Represents a user object for Firebase import with fields like UID, Email, PhotoURL, and PhoneNumber.
*   UserAndMetadataToImport: A wrapper structure combining **user import data** and associated **metadata**.

**Error Handling:**

*   **Password File Errors:** If the password file fails to open or parse, an error message is printed, and the function exits gracefully.
*   **User Parsing Errors:** If a user’s password or identity data fails to parse, the code logs the error and continues processing other users.

To log in and test the credentials migrated across you will need to have a client that connects to the tenants, this blog post does not contain the instructions to configure that, however you can look at [https://github.com/firebase/firebaseui-web](https://github.com/firebase/firebaseui-web) for a starting point to help you establish a client for quick validation of your data.

## Did this help?

*   **Like, comment and share this article**
*   **Follow this blog** to receive notifications of new postings
*   **View** [previous postings](https://robertleggett.com.au/)
